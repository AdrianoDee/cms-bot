#!/bin/sh -ex
# Updates a branch by doing the following:
# - switch to the target branch
# - Merge the source branch but keep anything on the development branch
#   in case of conflicts.
# - Update the target branch. 
function updateBranch()
{
  COMMITS_LIST=$1
  REPO=`echo $2 | tr '[a-z]' '[A-Z]'`
  SOURCE_BRANCH=$3
  TARGET_BRANCH=$4
  STRATEGY=$5
  if [ "X$STRATEGY" != "X" ]; then STRATEGY="-X $STRATEGY" ; fi
  rm -f $WORKSPACE/errors &&\
  echo ">git fetch -q --force origin" > $WORKSPACE/cmds &&\
  echo ">git clean -fdx" >> $WORKSPACE/cmds &&\
  echo ">git checkout -q --force $TARGET_BRANCH" >> $WORKSPACE/cmds &&\
  echo ">git reset --hard origin/$TARGET_BRANCH" >> $WORKSPACE/cmds &&\
  git clean -fdx &&\
  git checkout -q --force $TARGET_BRANCH &&\
  git reset --hard origin/$TARGET_BRANCH  &&\
  PRMSG="" &&\
  if [ "X$COMMITS_LIST" = "X" ] ; then \
    echo ">git merge --no-ff $STRATEGY origin/$SOURCE_BRANCH" >> $WORKSPACE/cmds &&\
    (git merge --no-ff $STRATEGY origin/$SOURCE_BRANCH >> $WORKSPACE/cmds 2>&1) || touch $WORKSPACE/errors &&\
    PRMSG="Merge $SOURCE_BRANCH into $TARGET_BRANCH." ;\
  else \
    git branch -D auto-fwport || true &&\
    git checkout -b auto-fwport &&\
    for c in $(echo $COMMITS_LIST | tr ',' '\n') ; do \
      PRMSG=$(git show --pretty=format:%s $c | head -1 | grep '^Merge pull request #[1-9][0-9]* from ') || true &&\
      if [ "X$PRMSG" = "X" ] ; then \
        echo ">git cherry-pick -x $STRATEGY $c" >> $WORKSPACE/cmds &&\
        (git cherry-pick -x $STRATEGY $c >> $WORKSPACE/cmds 2>&1) || touch $WORKSPACE/errors ;\
      else \
        git checkout -q --force $TARGET_BRANCH &&\
        git merge --no-ff auto-fwport &&\
        git commit --amend -m "$PRMSG" &&\
        git checkout -q auto-fwport ;\
      fi ;\
    done &&\
    if [ "X$PRMSG" = "X" ] ; then \
      git checkout -q --force $TARGET_BRANCH &&\
      git merge --no-ff auto-fwport &&\
      PRMSG="Merge $SOURCE_BRANCH into $TARGET_BRANCH." ;\
    else \
      git checkout -q --force $TARGET_BRANCH && PRMSG="" ;\
    fi &&\
    git branch -D auto-fwport ;\
  fi &&\
  if [ -f $WORKSPACE/errors ] ; then (cat $WORKSPACE/cmds $WORKSPACE/cmds && exit 1) ; fi &&\
  if [ "X`git rev-parse origin/$TARGET_BRANCH`" != "X`git rev-parse $TARGET_BRANCH`" ]; then \
    if [ ! "X$PRMSG" = "X" ] ; then \
      git commit --amend -m "$PRMSG" ;\
    fi &&\
    echo git push origin $TARGET_BRANCH ;\
  fi
  echo "====> OK $SOURCE_BRANCH => $TARGET_BRANCH"
}

function getRepos()
{
  (export PYTHONPATH=$SCRIPT_PATH; echo -e "from forward_ports_map import GIT_REPO_FWPORTS as p\nprint ' '.join(p.keys())" | python)
}

function getBranches()
{
  if [ "X$2" = "X" ] ; then
    (export PYTHONPATH=$SCRIPT_PATH; echo -e "from forward_ports_map import GIT_REPO_FWPORTS as p\nif '$1' in p:\n  x=p['$1'].keys()\n  x.sort()\n  print ' '.join(x)" | python)
  else
    (export PYTHONPATH=$SCRIPT_PATH; echo -e "from forward_ports_map import GIT_REPO_FWPORTS as p\nif '$1' in p and '$2' in p['$1']:\n  print ' '.join(p['$1']['$2'])" | python)
  fi
}

REPO_NAME=$1
BRRANCH=$2
COMMITS=$3
GIT_USER="cms-sw"
SCRIPT_PATH="`dirname \"$0\"`"
SCRIPT_PATH="`(cd \"$SCRIPT_PATH\" && pwd)`"
WORKSPACE="${WORKSPACE-$PWD}"
if [ "X$REPO_NAME" = "X" ] ; then REPO_NAME=`getRepos`; COMMITS=""; fi
for full_repo in $REPO_NAME ; do
  case $full_repo in 
    */*) ;;
    *)   full_repo="${GIT_USER}/${full_repo}" ;;
  esac
  repo=`echo $full_repo |sed 's|.*/||'`
  echo "Working on ${full_repo} ..."
  cd "$WORKSPACE"
  if [ ! -d $repo ] ; then
    git clone git@github.com:${full_repo}
    cd $repo
    if [ X$HOME = X ]; then
      git config user.email 'cmsbuild@cern.ch'
      git config user.name  'CMS Build'
    fi
  else
    cd $repo
  fi
  git fetch -q --force origin
  if [ "X$BRRANCH" = "X" ] ; then
    BRRANCHES=`getBranches $repo`
    COMMITS=""
  else
    BRRANCHES=$BRRANCH
  fi
  for src in $BRRANCHES; do
    echo "Forward porting branch $src"
    for des in `getBranches $repo $src`; do
      (updateBranch "$COMMITS" "$repo" "$src" $(echo $des | tr ':' ' ')) || true
    done
  done
done
