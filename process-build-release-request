#!/usr/bin/env python
from optparse import OptionParser
from github import Github
from os.path import expanduser
from categories import AUTO_BUILD_RELEASE
import re
import json
import urllib2

# 
# Processes a github issue to check if it is requesting the build of a new release
# If the issue is not requesting any release, it ignores it. 
#

# -------------------------------------------------------------------------------
# Global Variables
# --------------------------------------------------------------------------------
GH_CMSSW_ORGANIZATION = 'cms-sw'
GH_CMSSW_REPO = 'cmssw'
BUILD_REL = '^[Bb]uild[ ]+(CMSSW_[^ ]+)'
NOT_AUTHORIZED_MSG = 'You are not authorized to trigger the build of a release.'
CONFIG_MAP_FILE = 'config.map'
NO_ARCHS_FOUND_MSG = 'No architecures to build found for {rel_name}. Please check that you entered a ' \
                     'valid release name or that the IBs are currently enabled for that release queue.'
RELEASE_BASE_URL = 'https://github.com/cms-sw/cmssw/releases/tag/%s'
RELEASE_CREATED_MSG = 'Release created: %s'
QUEUING_BUILDS_MSG = 'Queuing Jenkins build for the following architectures: %s '
QUEING_UPLOADS_MSG = 'Queing Jenkins upload for {architecture}'
BUILD_QUEUED_LABEL = 'build-release-queued'
BUILD_STARTED_LABEL = 'build-release-started'
JENKINS_CMSSW_X_Y_Z = 'CMSSW_X_Y_Z'
JENKINS_ARCH = 'ARCH'
JENKINS_ISSUE_NUMBER = 'ISSUE_NUMBER'
JENKINS_MACHINE_NAME = 'MACHINE_NAME'
JENKINS_CMSSW_QUEUE = 'CMSSW_QUEUE'

UPLOAD_COMMENT = 'upload %s'
DEFAULT_CHECK_COMMENT = ( AUTO_BUILD_RELEASE + [ 'cmsbuild' ] )

#
# Creates a properties file in Jenkins to trigger the upload
# it needs to know the machine that was used for the build
#
def create_properties_files_upload( release_name , arch , issue_number , machine_name ):

  out_file_name = 'upload-%s-%s.properties' % ( release_name , arch )
  if opts.dryRun:
    print 'Not creating properties file (dry-run):\n %s' % out_file_name
  else:
    print 'Creating properties file for %s' % arch
    out_file = open( out_file_name , 'w' )
    out_file.write( '%s=%s\n' % ( JENKINS_CMSSW_X_Y_Z , release_name ) )
    out_file.write( '%s=%s\n' % ( JENKINS_ARCH , arch ) )
    out_file.write( '%s=%s\n' % ( JENKINS_ISSUE_NUMBER , issue_number ) )
    out_file.write( '%s=%s\n' % ( JENKINS_MACHINE_NAME , machine_name ) )


#
# for each architecture, reads the message to see if they are asking to upload a release
# retruns True if it is going to trigger the upload, False otherwise.
#
def check_and_trigger_upload( release_name , issue , comments, architectures ):
  triggered_upload = False
  for arch in architectures:
    pattern = 'The build has finished sucessfully for the architecture %s .*' % arch
    if not search_in_comments( comments , DEFAULT_CHECK_COMMENT , pattern ):
      print 'Not ready to upload %s ' % arch
      continue
    else:
      pattern = ( UPLOAD_COMMENT % arch )
      upload_requested = search_in_comments( comments , DEFAULT_CHECK_COMMENT , pattern )
      pattern = ( QUEING_UPLOADS_MSG.format( architecture=arch ) )
      already_triggered = search_in_comments( comments , DEFAULT_CHECK_COMMENT  , pattern )
      if upload_requested and not already_triggered:
        print 'Upload requested for %s' % arch
        pattern = 'The build has started for %s .*' % arch
        building_msg = search_in_comments( comments , DEFAULT_CHECK_COMMENT  , pattern )
        if not building_msg:
          print 'Build machine not found in the comments, something is wrong'
          exit( 1 )
        else:
          print 'Triggering upload for %s' % arch
          machine = building_msg[ 0 ].split( ' ' )[ -1 ]
          create_properties_files_upload( release_name , arch , issue.number , machine )
          post_message( issue , QUEING_UPLOADS_MSG.format( architecture=arch ) )
          triggered_upload = True
      else:
        print 'Upload for %s no requested yet, or already triggered' % arch

  return triggered_upload
#
# Searches in the comments if there is a comment made from  the given users  that
# matches the given pattern. It returns a list with the matched comments.
#
def search_in_comments( comments , user_logins , pattern ):
  found_comments = []
  requested_comment_bodies = [ c.body for c in comments if c.user.login in user_logins ]
  for body in requested_comment_bodies:
    if re.match( pattern , body ):
      found_comments.append( body )
  return found_comments


#
# Checks if the issue has already been seen so the issue will not be processed again
# Returns True if the issue needs to be processed, False if not
# 
def check_if_already_processed( issue ):
  comments = [ c for c in issue.get_comments( ) ]
  comment_bodies = [ c.body for c in comments if c.user.login == 'cmsbuild' ]
  for body in comment_bodies:
    if 'Release created' in body:
      return True
    if 'Queuing Jenkins build' in body:
      return True
    if 'You are not authorized' in body:
      return True

  return False
#
#  Creates the properties files to trigger the build in Jenkins
#
def create_properties_files(release_name, architectures, issue_number, queue):
  if opts.dryRun:
    print 'Not creating properties file (dry-run):\n %s' % out_file_name
    return

  for arch in architectures:
    out_file_name = 'build-%s-%s.properties' % ( release_name , arch )
    print 'Creating properties file for %s' % arch
    out_file = open( out_file_name , 'w' )
    out_file.write( '%s=%s\n' % ( JENKINS_CMSSW_X_Y_Z , release_name ) )
    out_file.write( '%s=%s\n' % ( JENKINS_ARCH , arch ) )
    out_file.write( '%s=%s\n' % ( JENKINS_ISSUE_NUMBER , issue_number ) )
    out_file.write( '%s=%s\n' % ( JENKINS_CMSSW_QUEUE , queue) )

    
#
# Creates a release in github
# If dry-run is selected it doesn't create the release and just prints that
#
def create_release_github( repository , release_name , branch):
  if opts.dryRun:
    print 'Not creating release (dry-run):\n %s' % release_name
    return 

  print 'Creating release:\n %s' % release_name
  # creating releases will be available in the next version of pyGithub
  params = { "tag_name" : release_name, 
           "target_commitish" : branch,
           "name" : release_name,
           "body" : 'cms-bot is going to build this release',
           "draft" : False, 
           "prerelease" : False }

  token = open(expanduser("~/.github-token")).read().strip()
  request = urllib2.Request("https://api.github.com/repos/cms-sw/cmssw/releases",
  headers={"Authorization" : "token " + token})
  request.get_method = lambda: 'POST'
  print '--'
  print urllib2.urlopen( request, json.dumps( params  ) ).read()
  print


#
# Reads config.map and returns a list of the architectures for which a release needs to be built.
# If the list is empty it means that it didn't find any architecture for that release queue, or 
# that the IBs are disabled.
#
def get_config_map_properties():
  specs = []
  f = open( CONFIG_MAP_FILE , 'r' )
  lines = [l.strip(" \n\t;") for l in f.read().split("\n") if l.strip(" \n\t;")]
  print lines
  for line in lines:
    entry = dict(x.split("=",1) for x in line.split(";") if x)
    specs.append(entry)
  return specs

#
# Adds a label to the issue in github
# if dry-run is selected it doesn't add the label and just prints it
def add_label( issue , label ):
  if opts.dryRun:
    print 'Not adding label (dry-run):\n %s' % label
  else:
    print 'Adding label:\n %s' % label
    issue.add_to_labels( label )

#
# posts a message to the issue in github
# if dry-run is selected it doesn't post the message and just prints it
#
def post_message( issue , msg ):
  if opts.dryRun:
    print 'Not posting message (dry-run):\n %s' % msg
  else:
    print 'Posting message:\n %s' % msg 
    issue.create_comment( msg )

# -------------------------------------------------------------------------------
# Start of execution 
# --------------------------------------------------------------------------------

if __name__ == "__main__":
  parser = OptionParser( usage="%prog <issue-id>" )
  parser.add_option( "-n" , "--dry-run" , dest="dryRun" , action="store_true", help="Do not post on Github", default=False )
  parser.add_option( "-f" , "--force" , dest="force" , action="store_true", help="Ignore previous comments in the issue and proccess it again", default=False )
  parser.add_option( "-c", "--check-upload", dest="check_upload" , action="store" , help="Check if one of the authorized users has written the upload message"
                                                                                        "for the architecture given as a parameter. It exits with 0 if it finds"
                                                                                        "a message with the structure 'upload <architecture>', if not it exits"
                                                                                        " with 1"  )
  opts, args = parser.parse_args( )

  if len( args ) != 1:
    parser.print_help()
    parser.error( "Too many arguments" )
  
  issue_id  = int( args[ 0 ] )
  gh = Github( login_or_token=open( expanduser( "~/.github-token" ) ).read( ).strip( ) )
  issue = gh.get_organization( GH_CMSSW_ORGANIZATION ).get_repo( GH_CMSSW_REPO ).get_issue( issue_id )
  comments = [ c for c in issue.get_comments( ) ]
 
  # 1. Is this a pull request?
  if issue.pull_request:
    print 'This is a pull request, ignoring.'
    exit( 0 )
  
  m = re.match(BUILD_REL, issue.title)
  # 2. Is this issue meant to build a release?
  if not m:
    print 'This issue is not for building a release, ignoring.'
    exit( 0 )
  
  # 3. Is the author authorized to trigger a build?
  if not issue.user.login in AUTO_BUILD_RELEASE:
    print 'User not authorized'
    if not search_in_comments( comments, DEFAULT_CHECK_COMMENT , NOT_AUTHORIZED_MSG ): 
      post_message( issue , NOT_AUTHORIZED_MSG )
    else:
      print 'Already posted about this'
    exit( 0 )

  release_name = m.group(1)

  # Get the release queue from the release name.
  print release_name
  m = re.match("(CMSSW_[0-9]+_[0-9]+)_[0-9]+(_SLHC[0-9]*|)(_pre[0-9]+|_[a-zA-Z]*patch[0-9]+|)(_[^_]*|)", release_name)
  release_queue = "".join([x for x in m.group(1,4)] + ["_X"] + [x.strip("0123456789") for x in m.group(2)])

  print release_queue
  specs = get_config_map_properties()
  architectures = [x["SCRAM_ARCH"] for x in specs
                   if x["RELEASE_QUEUE"] == release_queue and not "DISABLED" in x]

  # Check if we have at least one architecture to build and complain if not.
  if not architectures:
    print 'no archs found for the requested release'
    msg = NO_ARCHS_FOUND_MSG.format( rel_name=release_name )
    if search_in_comments( comments, DEFAULT_CHECK_COMMENT , msg ):
      print 'Already notified about it'
    else:
      post_message( issue , msg )
    exit( 0 )

  # Are they asking to upload an architecture? 
  if check_and_trigger_upload( release_name , issue , comments , architectures ):
    print 'Uploads triggered'
    exit( 0 )

  # Determine the release branch (which is the same as the release queue if not
  # specified) and start the build if needed.
  release_branches = [x["RELEASE_BRANCH"] for x in specs
                      if x["RELEASE_QUEUE"] == release_queue and "RELEASE_BRANCH" in x and not "DISABLED" in x]
  
  release_branch = release_queue
  if len(release_branches):
    release_branch = release_branches[0]

  if not opts.force:
    if search_in_comments( comments, DEFAULT_CHECK_COMMENT , QUEUING_BUILDS_MSG[:20] ):
      print 'Build in progress or already uploaded. Nothing to do, ignoring.' 
      exit( 0 )

  cmssw_repo = gh.get_organization( GH_CMSSW_ORGANIZATION ).get_repo( GH_CMSSW_REPO )
  create_release_github( cmssw_repo , release_name , release_branch )
  msg = RELEASE_CREATED_MSG % ( RELEASE_BASE_URL % release_name )
  post_message( issue , msg )

  create_properties_files( release_name , architectures , issue_id, release_queue)

  msg = QUEUING_BUILDS_MSG % ', '.join( architectures )
  post_message( issue , msg )
  #add_label( issue, BUILD_QUEUED_LABEL )
